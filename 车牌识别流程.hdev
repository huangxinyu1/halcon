<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.1">
<procedure name="main">
<interface/>
<body>
<c>****************************************************************************</c>
<c>*1.采集助手采集视频图像</c>
<c as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[1,1]" as_ord="1">* Image Acquisition 02: Code generated by Image Acquisition 02</c>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[1,2,1]" as_ord="1">open_framegrabber ('DirectFile', 1, 1, 0, 0, 0, 0, 'default', 8, 'rgb', -1, 'false', 'default', 'default', -1, -1, AcqHandle)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[2,1]" as_ord="1">grab_image_start (AcqHandle, -1)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[2,2]" as_ord="1">while (true)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[2,3]" as_ord="1">    grab_image_async (Image, AcqHandle, -1)</l>
<c as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[2,4]" as_ord="1">    * Image Acquisition 02: Do something</c>
<c>    *2.二值化处理图像</c>
<l>    threshold (Image, Region, 128, 255)</l>
<c>    *3.开运算处理图像</c>
<l>    opening_rectangle1 (Region, RegionOpening, 10, 10)</l>
<c>    *4.图像中间有洞填充</c>
<l>    fill_up (RegionOpening, RegionFillUp)</l>
<c>    *求与水平面的夹角</c>
<l>    orientation_region (RegionFillUp, Phi)</l>
<c>    *求面积</c>
<l>    area_center (RegionFillUp, Area, Row, Column)</l>
<c>    *图像转正</c>
<l>    affine_trans_image (Image, ImageAffineTrans, Area, 'constant', 'false')</l>
<c>    *5.测量助手 </c>
<c>    *没有图片稍后生成</c>
<c as_id="measure1d" as_name="Measure 02" as_grp="[1,1]" as_ord="1">    * Measure 02: Code generated by Measure 02</c>
<c as_id="measure1d" as_name="Measure 02" as_grp="[2,1]" as_ord="1">    * Measure 02: You need at least one ROI before generating code!</c>
<c>    </c>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[3,1]" as_ord="1">endwhile</l>
<l as_id="image_acquisition" as_name="Image Acquisition 02" as_grp="[4,1]" as_ord="1">close_framegrabber (AcqHandle)</l>
<c></c>
<c></c>
<c></c>
<c>**************************************************************************</c>
<c>*车牌识别</c>
<c>**************************************************************************</c>
<c></c>
<c>*1.读取图像</c>
<l>read_image (Image1, 'printer_chip/printer_chip_01')</l>
<c>*2.转化为灰度图像</c>
<l>rgb1_to_gray (Image1, GrayImage)</l>
<c>*3.二值化</c>
<l>threshold (GrayImage, Region1, 128, 255)</l>
<c>*4.去除噪声</c>
<l>opening_rectangle1 (Region1, RegionOpening1, 10, 10)</l>
<c>*5.形状选择</c>
<l>connection (RegionOpening1, ConnectedRegions)</l>
<c>*6.特征选择</c>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 150, 99999)</l>
<c>*7.排序字符分割</c>
<l>sort_region (SelectedRegions, SortedRegions, 'first_point', 'true', 'row')</l>
<c>*8.读入分类器</c>
<l>read_ocr_class_mlp (Area, OCRHandle)</l>
<c>*9.识别</c>
<l>do_ocr_multi_class_mlp (SortedRegions, GrayImage, OCRHandle, Class, Confidence)</l>
<c></c>
<c>******************************************************************</c>
<c>*识别车牌</c>
<c>**************************************************</c>
<c>*读取图片</c>
<c>*定位根据颜色拆分通道</c>
<l>decompose3 (GrayImage, Image11, Image2, Image3)</l>
<c>*从rgb空间拆成hsv空间</c>
<l>trans_from_rgb (Image11, Image11, Image11, ImageResult1, ImageResult2, ImageResult3, 'hsv')</l>
<c>*找到合适的分量，灰度直方图提取</c>
<l>threshold (ImageResult1, Region2, 128, 255)</l>
<c>*形态学提取</c>
<l>opening_rectangle1 (Region2, RegionOpening2, 10, 10)</l>
<c>*填充矩形</c>
<l>fill_up (RegionOpening2, RegionFillUp1)</l>
<c>*切断</c>
<l>connection (RegionFillUp1, ConnectedRegions1)</l>
<c>*特征选择切分</c>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 150, 99999)</l>
<c>*形状转化</c>
<l>shape_trans (SelectedRegions1, RegionTrans, 'convex')</l>
<c>*求角度</c>
<l>orientation_region (RegionTrans, Phi1)</l>
<c>*求面积</c>
<l>area_center (RegionTrans, Area1, Row1, Column1)</l>
<c>*转正</c>
<l>vector_angle_to_rigid (Row1, Column1, Phi1, Row1, Column1, Phi1, HomMat2D)</l>
<c>*放射变换</c>
<l>affine_trans_image (ImageResult1, ImageAffineTrans1, HomMat2D, 'constant', 'false')</l>
<c>*区域进行放射变化，以便用于图像的截取</c>
<l>affine_trans_region (RegionTrans, RegionAffineTrans, HomMat2D, 'nearest_neighbor')</l>
<c>*截取图像</c>
<c></c>
<l>reduce_domain (ImageAffineTrans1, RegionAffineTrans, ImageReduced)</l>
<c>*改变字体黑变暗，暗变亮</c>
<l>invert_image (ImageAffineTrans1, ImageInvert)</l>
<c>*分割图像</c>
<l>rgb1_to_gray (ImageAffineTrans1, GrayImage1)</l>
<c>*二值化</c>
<l>threshold (GrayImage1, Region3, 128, 255)</l>
<l>connection (Region3, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions2, 'area', 'and', 150, 99999)</l>
<l>sort_region (SelectedRegions2, SortedRegions1, 'first_point', 'true', 'row')</l>
<c></c>
<l>read_ocr_class_mlp (HomMat2D, OCRHandle1)</l>
<c>*识别</c>
<l>do_ocr_multi_class_mlp (SortedRegions1, GrayImage1, OCRHandle1, Class1, Confidence1)</l>
<c></c>
<c>*显示字体在图片上</c>
<l>disp_message (窗体名, Class1, 'window', Row1, Column1, 'black', 'true')</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
